---
layout: post
title:  "Java의 정석 정리"
date:   2023-04-06 17:03:36 +0530
categories: JAVA Book
---

# 자바의 정석

# 6. 객체지향 프로그래밍
![Untitled](/assets/posts/2023-04-06-basic-java/0.png){: .center}
- 내용
    
    **객체지향언어의 주요특징**
    
    - 코드의 재사용성이 높다
    - 코드의 관리가 용이하다
    - 신뢰성이 높은 프로그램을 가능하게 한다. → 제어자와 메서드, 코드의 중복 제거
    
    **클래스**란 객체를 정의해 놓은 것, **객체**는 클래스에 정의된 내용대로 **메모리**에 생성된 것
    
    클래스로부터 객체를 만드는 과정을 **인스턴스화(instantiate)**, 클래스로부터 만들어진 객체를 **인스턴스(instance)**라 부름
    
    객체는 **속성**과 **기능**으로 이루어지며 객체가 가지고 있는 속성과 기능을 그 **객체의 멤버(member)**라 부름
    
    ![Untitled](/assets/posts/2023-04-06-basic-java/1.png)
    
    **25** : 메모리에 변수 t에 대한 공간이 할당
    
    **26** : new에 의해 Tv클래스의 인스턴스가 메모리에 생성되고 각 멤버 변수는 자료형에 맞게 초기화 → t = new Tv()의 `=` 에 의해 Tv인스턴스의 주소값이 참조 변수 t에 저장 
    
    인스턴스는 참조변수를 통해서만 다룰 수 있고, **참조변수의 타입은 인스턴스의 타입과 일치**해야 함.
    
    ![Untitled](/assets/posts/2023-04-06-basic-java/2.png)
    
    **24 - 25 :** t1 , t2 각각의 참조 변수와 인스턴스는 메모리의 전부 다른 주소에 할당
    
    **29 - 33** : t1, t2의 인스턴스 주소가 다르기 때문에 t1의 멤버 변수인 cahnnel을 수정하면 t1만 수정
    
    **35 - 37 :** t2의 참조 변수에 t1 인스턴스의 주소를 할당(t2가 원래 참조 하고 있던 인스턴스는 더 이상 사용할 수 없음) t2의 멤버 변수를 확인하면 t1의 멤버 변수와 동일
    
    **40 - 48** : t1, t2 참조 변수 모두 t1의 인스턴스를 바라보고 있기때문에 동일한 주소의 메소드가 동작
    
    자신을 참조하고 있는 참조 변수가 하나도 없는 인스턴스는 더 이상 사용될 수 없어 **가비지 컬렉터(garbage collector)**에 의해 자동적으로 메모리에서 제거
    
    - 참고 문서
        
        [[Java] Garbage Collection(가비지 컬렉션)의 개념 및 동작 원리 (1/2)](https://mangkyu.tistory.com/118)
        
    
    하나의 인스턴스를 여러 개의 참조 변수가 가리키는 것은 가능, 여러 인스턴스를 하나의 참조변수가 가리키는 것을 불가능
    
    객체를 배열로 다루는 것이 가능한데 이를 **객체 배열** 이라 하는데 객체 배열안에는 **객체의 주소를 저장.** 즉, 객체 배열은 참조변수들을 하나로 묶은 참조 변수 배열
    
    ![Untitled](/assets/posts/2023-04-06-basic-java/3.png)
    
    **24 :** 참조변수 배열을 생성 
    
    **26 - 28 :** 객체를 생성해서 각 배열의 각 요소에 인스턴스 주소 저장
    
     **사용자 정의 타입(user-defined type)**이란 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 말하는데 객체지향언어에서 클래스가 곧 사용자 정의 타입